<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>My first Three.js app</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
      </style>
  </head>
  <body>
    <!-- <p id = "screene"></p> -->
    <script src="js/three.js"></script>
    <script>
    	var speed_of_rotation_x = 0;
    	var speed_of_rotation_y = 0;
    	var pi2 = Math.PI * 2;

        var size_coef = 0.336487907;
        var width = window.innerWidth;
        var height = window.innerHeight;
        var half_cube_size = Math.round((height * size_coef) / 2);
    	var cube_screen_cords = {"up left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) - half_cube_size],
                                "up right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) - half_cube_size],
                                "down left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) + half_cube_size],
                                "down right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) + half_cube_size]};
        let screenLog = document.querySelector('#screene');

        function screenUpdateCheck(){
            width = window.innerWidth;
            height = window.innerHeight;
            var camera = new THREE.PerspectiveCamera( size_of_scene, width / height, 0.1, 5 );  // camera perspective
            camera.position.z = 2;
            renderer.setSize( width, height);  // cube lesson size on the screene
            document.body.appendChild( renderer.domElement);
            renderer.render( scene, camera );
            // limit dots
            half_cube_size = Math.round((height * size_coef) / 2);
            coeff = 1
            cube_screen_cords = {"up left": [Math.round(width / 2) - half_cube_size * coeff, Math.round(height / 2) - half_cube_size * coeff],
                                "up right": [Math.round(width / 2) + half_cube_size * coeff, Math.round(height / 2) - half_cube_size * coeff],
                                "down left": [Math.round(width / 2) - half_cube_size * coeff, Math.round(height / 2) + half_cube_size * coeff],
                                "down right": [Math.round(width / 2) + half_cube_size * coeff, Math.round(height / 2) + half_cube_size * coeff]};
        }

        function buf_check(side, x, y, bufer_size){
            if (side == "up"){
                in_x = (x >= cube_screen_cords['up left'][0] && x <= cube_screen_cords['up right'][0]);
                y_buf_limit = cube_screen_cords["up left"][1] - (half_cube_size * bufer_size);
                in_y = (y >= y_buf_limit && y <= cube_screen_cords['up left'][1]);
                big_bufer = (in_x && in_y);

                left_limit = cube_screen_cords['up left'][0] + (half_cube_size * bufer_size);
                right_limit = cube_screen_cords['up right'][0]  - (half_cube_size * bufer_size);
                in_x = ((x >= left_limit && x <= right_limit));
                up_limit = cube_screen_cords["up left"][1];
                down_limit = (cube_screen_cords['up left'][1] + (half_cube_size * bufer_size));
                in_y = (y >=  up_limit && y <= down_limit);
                small_bufer =  (in_x && in_y);

                return big_bufer || small_bufer;
            }
            if (side == "down"){
                in_x = (x >= cube_screen_cords['up left'][0] && x <= cube_screen_cords['up right'][0]);
                up_limit = cube_screen_cords["down left"][1];
                down_limit = cube_screen_cords["down left"][1] + (half_cube_size * bufer_size);
                in_y = (y >= up_limit && y <= down_limit);
                big_bufer = (in_x && in_y);

                left_limit = cube_screen_cords['up left'][0] + (half_cube_size * bufer_size);
                right_limit = cube_screen_cords['up right'][0]  - (half_cube_size * bufer_size);
                in_x = (x >= left_limit && x <= right_limit);
                up_limit = cube_screen_cords["down left"][1] - (half_cube_size * bufer_size);
                down_limit = cube_screen_cords['down left'][1];
                in_y = (y >=  up_limit && y <= down_limit);
                small_bufer =  (in_x && in_y);
                return big_bufer || small_bufer;
            }
            if (side == "left"){
                left_limit = cube_screen_cords['up left'][0] - (half_cube_size * bufer_size);
                in_x = (x >=  left_limit && x <= cube_screen_cords['up left'][0]);
                in_y = (y >= cube_screen_cords["up left"][1] && y <= cube_screen_cords["down left"][1]);
                big_bufer = (in_x && in_y);

                left_limit = cube_screen_cords['up left'][0];
                right_limit = cube_screen_cords['up left'][0] + (half_cube_size * bufer_size);
                in_x = (x >= left_limit && x <= right_limit);
                up_limit = cube_screen_cords["up left"][1] + (half_cube_size * bufer_size);
                down_limit = cube_screen_cords['down left'][1] - (half_cube_size * bufer_size);
                in_y = (y >=  up_limit && y <= down_limit);
                small_bufer =  (in_x && in_y);
                return big_bufer || small_bufer;
            }
            if (side == "right"){
                right_limit = cube_screen_cords['up right'][0] + (half_cube_size * bufer_size);
                in_x = (x >= cube_screen_cords["up right"][0] && x <= right_limit);
                in_y = (y >= cube_screen_cords["up right"][1] && y <= cube_screen_cords["down right"][1]);
                big_bufer = (in_x && in_y);

                right_limit = cube_screen_cords['up right'][0];
                left_limit = cube_screen_cords['up right'][0] - (half_cube_size * bufer_size);
                in_x = (x >= left_limit && x <= right_limit);
                up_limit = cube_screen_cords["up right"][1] + (half_cube_size * bufer_size);
                down_limit = cube_screen_cords['down right'][1] - (half_cube_size * bufer_size);
                in_y = (y >=  up_limit && y <= down_limit);
                small_bufer =  (in_x && in_y);
                return big_bufer || small_bufer;
            }

        }

        function mouseListener(e) {
            if (e.which == 1){
                mousex = e.clientX;
                mousey = e.clientY;
                // %20 bufer for pressing
                bufer_coef = 0.3

                if (buf_check("up", mousex, mousey, bufer_coef)){
                    speed_of_rotation_y = 0.1;
                }
                if (buf_check("down", mousex, mousey, bufer_coef)){
                    speed_of_rotation_y = -0.1;
                }
                if (buf_check("right", mousex, mousey, bufer_coef)){
                    speed_of_rotation_x = -0.1;
                }
                if (buf_check("left", mousex, mousey, bufer_coef)){
                    speed_of_rotation_x = 0.1;
                }

                // if (mousex >= cube_screen_cords["up left"][0] && mousex <= cube_screen_cords["up right"][0] && mousey >= cube_screen_cords["up left"][1] && mousey <= cube_screen_cords["down left"][1]){
                //     speed_of_rotation_y = 0.1;
                // }
            }
        }

        function debug(){
            screenLog.innerText = `mousex ${mousex} mousey ${mousey}
            x1 ${cube_screen_cords["up left"][0]} y1 ${cube_screen_cords["up left"][1]}
            x2 ${cube_screen_cords["up right"][0]} y2 ${cube_screen_cords["up right"][1]}
            mousex >= x1 ${mousex >= cube_screen_cords['up left'][0]} 
            mousex <= x2 ${mousex <= cube_screen_cords['up right'][0]} 
            mousey <= y1 ${mousey <= cube_screen_cords['up left'][1]}
            `;
            // screenLog.innerText = `mousex ${mousex} mousey ${mousey}
            // x1 ${cube_screen_cords["up left"][0]} y1 ${cube_screen_cords["up left"][1]}
            // x2 ${cube_screen_cords["up right"][0]} y2 ${cube_screen_cords["up right"][1]}
            // x3 ${cube_screen_cords["down left"][0]} y3 ${cube_screen_cords["down left"][1]}
            // x4 ${cube_screen_cords["down right"][0]} y4 ${cube_screen_cords["down right"][1]}
            // mousex >= x1 ${mousex >= cube_screen_cords['up left'][0]} 
            // mousex <= x2 ${mousex <= cube_screen_cords['up right'][0]} 
            // mousey <= y1 ${mousey <= cube_screen_cords['up left'][1]}
            // `;
        }

        function cubeRotation(){
            cube.rotation.y += speed_of_rotation_x;
            cube.rotation.x += speed_of_rotation_y;


            degreex = cube.rotation.y;
            degreey = cube.rotation.x;

            if (degreex > 0){
                if ((degreex % (Math.PI * 0.5)) < 0.1){
                    cube.rotation.y = 0;
                    speed_of_rotation_x = 0;
                    }
                }
            if (degreex < 0) {
                if (((pi2 + degreex) % (Math.PI * 0.5)) < 0.1){
                    cube.rotation.y = 0;
                    speed_of_rotation_x = 0;
                }
            }
            if (degreey > 0){
                if ((degreey % (Math.PI * 0.5)) < 0.1){
                    cube.rotation.x = 0;
                    speed_of_rotation_y = 0;
                }
            }
            if (degreey < 0){
                if (((pi2 + degreey) % (Math.PI * 0.5)) < 0.1){
                    cube.rotation.x = 0;
                    speed_of_rotation_y = 0;
                }
            }
        }
        function render() {
            requestAnimationFrame( render );
            cubeRotation();
            screenUpdateCheck()
            // debug();
        }

        document.addEventListener('mousedown', mouseListener);

    	var scene = new THREE.Scene();
        size_of_scene = 90;
		var camera = new THREE.PerspectiveCamera( size_of_scene, window.innerWidth / window.innerHeight, 0.1, 5 );  // camera perspective
        camera.position.z = 2;

		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight);  //cube lesson size on the screen
		document.body.appendChild( renderer.domElement);

		var geometry = new THREE.BoxGeometry( 1, 1, 1 );
		const loader = new THREE.TextureLoader();
        img = 'images/glommer.png'
        const materials = [
            new THREE.MeshBasicMaterial({map: loader.load(img)}),
            new THREE.MeshBasicMaterial({map: loader.load(img)}),
            new THREE.MeshBasicMaterial({map: loader.load(img)}),
            new THREE.MeshBasicMaterial({map: loader.load(img)}),
            new THREE.MeshBasicMaterial({map: loader.load(img)}),
            new THREE.MeshBasicMaterial({map: loader.load(img)}),
        ];
        const cube = new THREE.Mesh(geometry, materials);
        scene.add( cube );
  		render();
        
    </script>
  </body>
</html>
