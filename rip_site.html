<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>My first Three.js app</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
      </style>
  </head>
  <body>
    <!-- <p id = "screene"></p> -->
    <script src="js/three.js"></script>
    <script>
    	var speed_of_rotation_x = speed_of_rotation_y = 0.1;
        var angle_of_rotation_x = 0;
        var angle_of_rotation_y = 0;
    	var pi2 = Math.PI * 2;

        var size_coef = 0.336487907;
        var width = window.innerWidth;
        var height = window.innerHeight;
        var start_of_scene_z = 0.1;
        var end_of_scene_z = 5;
        var half_cube_size = Math.round((height * size_coef) / 2);
    	var cube_screen_cords = {"up left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) - half_cube_size],
                                "up right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) - half_cube_size],
                                "down left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) + half_cube_size],
                                "down right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) + half_cube_size]};
        var cube_sides_x = ["front", "right", "back", "left"];
        var cube_sides_y = ["x side", "up", "x side", "down"];
        var current_side_x = 0;
        var current_side_y = 0;
        let screenLog = document.querySelector('#screene');

        function screenUpdateCheck(){
            width = window.innerWidth;
            height = window.innerHeight;
            camera = new THREE.PerspectiveCamera( size_of_scene, width / height, 0.1, 5);  // camera perspective
            camera.position.z = 2;
            renderer.setSize( width, height);  // cube lesson size on the screene
            document.body.appendChild( renderer.domElement);
            renderer.render( scene, camera );

            geometry = new THREE.BoxGeometry( 1, 1, 1 );
            const loader = new THREE.TextureLoader();
            materials = [
                new THREE.MeshBasicMaterial({map: loader.load(right_img)}), // right
                new THREE.MeshBasicMaterial({map: loader.load(left_img)}),  // left
                new THREE.MeshBasicMaterial({map: loader.load(up_img)}),    // up
                new THREE.MeshBasicMaterial({map: loader.load(down_img)}),  // down
                new THREE.MeshBasicMaterial({map: loader.load(front_img)}), // front
                new THREE.MeshBasicMaterial({map: loader.load(back_img)}),  // back
            ];
            old_rot_x = cube.rotation.x
            old_rot_y = cube.rotation.y
            old_rot_z = cube.rotation.z
            scene.remove(cube);
            //alert("Hy");
            cube = new THREE.Mesh(geometry, materials);
            cube.rotation.x = old_rot_x;
            cube.rotation.y = old_rot_y;
            cube.rotation.z = old_rot_z;
            scene.add( cube );
            // scene.overrideMaterial = new THREE.MeshBasicMaterial({map: loader.load(front_img)});
            // alert(front_img)
            // limit dots
            half_cube_size = Math.round((height * size_coef) / 2);
            cube_screen_cords = {"up left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) - half_cube_size],
                                "up right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) - half_cube_size],
                                "down left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) + half_cube_size],
                                "down right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) + half_cube_size]};
        }

        function changeSides(img_ang){
            // alert(img_ang)
            if (img_ang == 0){
                up_img = "images/up.png";
            }
            if (img_ang == 90){
                up_img = "images/up_90.png";
            }
            if (img_ang == 180){
                up_img = "images/up_180.png";
            }
            if (img_ang == 270){
                up_img = "images/up_270.png";
            }
        }

        function buf_check(side, x, y, bufer_size){
            if (side == "up"){
                in_x = (x >= cube_screen_cords['up left'][0] && x <= cube_screen_cords['up right'][0]);
                y_buf_limit = cube_screen_cords["up left"][1] - (half_cube_size * bufer_size);
                in_y = (y >= y_buf_limit && y <= cube_screen_cords['up left'][1]);
                big_bufer = (in_x && in_y);

                left_limit = cube_screen_cords['up left'][0] + (half_cube_size * bufer_size);
                right_limit = cube_screen_cords['up right'][0]  - (half_cube_size * bufer_size);
                in_x = ((x >= left_limit && x <= right_limit));
                up_limit = cube_screen_cords["up left"][1];
                down_limit = (cube_screen_cords['up left'][1] + (half_cube_size * bufer_size));
                in_y = (y >=  up_limit && y <= down_limit);
                small_bufer =  (in_x && in_y);

                return big_bufer || small_bufer;
            }
            if (side == "down"){
                in_x = (x >= cube_screen_cords['up left'][0] && x <= cube_screen_cords['up right'][0]);
                up_limit = cube_screen_cords["down left"][1];
                down_limit = cube_screen_cords["down left"][1] + (half_cube_size * bufer_size);
                in_y = (y >= up_limit && y <= down_limit);
                big_bufer = (in_x && in_y);

                left_limit = cube_screen_cords['up left'][0] + (half_cube_size * bufer_size);
                right_limit = cube_screen_cords['up right'][0]  - (half_cube_size * bufer_size);
                in_x = (x >= left_limit && x <= right_limit);
                up_limit = cube_screen_cords["down left"][1] - (half_cube_size * bufer_size);
                down_limit = cube_screen_cords['down left'][1];
                in_y = (y >=  up_limit && y <= down_limit);
                small_bufer =  (in_x && in_y);
                return big_bufer || small_bufer;
            }
            if (side == "left"){
                left_limit = cube_screen_cords['up left'][0] - (half_cube_size * bufer_size);
                in_x = (x >=  left_limit && x <= cube_screen_cords['up left'][0]);
                in_y = (y >= cube_screen_cords["up left"][1] && y <= cube_screen_cords["down left"][1]);
                big_bufer = (in_x && in_y);

                left_limit = cube_screen_cords['up left'][0];
                right_limit = cube_screen_cords['up left'][0] + (half_cube_size * bufer_size);
                in_x = (x >= left_limit && x <= right_limit);
                up_limit = cube_screen_cords["up left"][1] + (half_cube_size * bufer_size);
                down_limit = cube_screen_cords['down left'][1] - (half_cube_size * bufer_size);
                in_y = (y >=  up_limit && y <= down_limit);
                small_bufer =  (in_x && in_y);
                return big_bufer || small_bufer;
            }
            if (side == "right"){
                right_limit = cube_screen_cords['up right'][0] + (half_cube_size * bufer_size);
                in_x = (x >= cube_screen_cords["up right"][0] && x <= right_limit);
                in_y = (y >= cube_screen_cords["up right"][1] && y <= cube_screen_cords["down right"][1]);
                big_bufer = (in_x && in_y);

                right_limit = cube_screen_cords['up right'][0];
                left_limit = cube_screen_cords['up right'][0] - (half_cube_size * bufer_size);
                in_x = (x >= left_limit && x <= right_limit);
                up_limit = cube_screen_cords["up right"][1] + (half_cube_size * bufer_size);
                down_limit = cube_screen_cords['down right'][1] - (half_cube_size * bufer_size);
                in_y = (y >=  up_limit && y <= down_limit);
                small_bufer =  (in_x && in_y);
                return big_bufer || small_bufer;
            }
        }

        function mouseListener(e) {
            if (e.which == 1){
                mousex = e.clientX;
                mousey = e.clientY;
                // size of press zone %30
                bufer_coef = 0.3

                if (buf_check("up", mousex, mousey, bufer_coef)){
                    if (angle_of_rotation_y == 0){
                        angle_of_rotation_y = Math.PI * 0.5;
                        current_side_y = (current_side_y + 1) % 4;
                        if (cube_sides_y[current_side_y] == "up"){
                            changeSides(90 * current_side_x)
                        }
                    }
                }
                else if (buf_check("down", mousex, mousey, bufer_coef)){
                    if (angle_of_rotation_y == 0){
                        angle_of_rotation_y = -Math.PI * 0.5;
                        current_side_y -= 1;
                        if (current_side_y == -1){current_side_y = 3};
                    }
                }
                else if (buf_check("right", mousex, mousey, bufer_coef)){
                    if (angle_of_rotation_x == 0){
                        angle_of_rotation_x = -Math.PI * 0.5;
                        current_side_x = (current_side_x + 1) % 4;
                    }
                }
                else if (buf_check("left", mousex, mousey, bufer_coef)){
                    if (angle_of_rotation_x == 0){
                        angle_of_rotation_x = Math.PI * 0.5;
                        current_side_x -= 1;
                        if (current_side_x == -1){current_side_x = 3};
                    }
                } else {
                    //alert(cube_sides_x[current_side_x]);
                    alert(cube_sides_y[current_side_y]);
                }
            }
        }
        function keyListener(e){
            if (e.which == 80){
                alert("?");
            }
        }

        function debug(){
            screenLog.innerText = `mousex ${mousex} mousey ${mousey}
            x1 ${cube_screen_cords["up left"][0]} y1 ${cube_screen_cords["up left"][1]}
            x2 ${cube_screen_cords["up right"][0]} y2 ${cube_screen_cords["up right"][1]}
            mousex >= x1 ${mousex >= cube_screen_cords['up left'][0]} 
            mousex <= x2 ${mousex <= cube_screen_cords['up right'][0]} 
            mousey <= y1 ${mousey <= cube_screen_cords['up left'][1]}
            `;
            // screenLog.innerText = `mousex ${mousex} mousey ${mousey}
            // x1 ${cube_screen_cords["up left"][0]} y1 ${cube_screen_cords["up left"][1]}
            // x2 ${cube_screen_cords["up right"][0]} y2 ${cube_screen_cords["up right"][1]}
            // x3 ${cube_screen_cords["down left"][0]} y3 ${cube_screen_cords["down left"][1]}
            // x4 ${cube_screen_cords["down right"][0]} y4 ${cube_screen_cords["down right"][1]}
            // mousex >= x1 ${mousex >= cube_screen_cords['up left'][0]} 
            // mousex <= x2 ${mousex <= cube_screen_cords['up right'][0]} 
            // mousey <= y1 ${mousey <= cube_screen_cords['up left'][1]}
            // `;
        }

        function cubeRotation(){
            if (angle_of_rotation_x > 0){
                if (angle_of_rotation_x > speed_of_rotation_x) {
                    cube.rotation.y += speed_of_rotation_x;
                    angle_of_rotation_x -= speed_of_rotation_x;
                }
                else {
                    cube.rotation.y += angle_of_rotation_x;
                    angle_of_rotation_x = 0;
                }
            }
            if (angle_of_rotation_x < 0){
                if (angle_of_rotation_x < -speed_of_rotation_x){
                    cube.rotation.y -= speed_of_rotation_x;
                    angle_of_rotation_x += speed_of_rotation_x;
                } else {
                    cube.rotation.y += angle_of_rotation_x;
                    angle_of_rotation_x = 0;
                }
            }
            if (angle_of_rotation_y > 0){
                if (angle_of_rotation_y > speed_of_rotation_y) {
                    cube.rotation.x += speed_of_rotation_y;
                    angle_of_rotation_y -= speed_of_rotation_y;
                }
                else {
                    cube.rotation.x += angle_of_rotation_y;
                    angle_of_rotation_y = 0;
                }
            }
            if (angle_of_rotation_y < 0){
                if (angle_of_rotation_y < -speed_of_rotation_y){
                    cube.rotation.x -= speed_of_rotation_y;
                    angle_of_rotation_y += speed_of_rotation_y;
                } else {
                    cube.rotation.x += angle_of_rotation_y;
                    angle_of_rotation_y = 0;
                }
            }
        }
        function render() {
            requestAnimationFrame( render );
            cubeRotation();
            screenUpdateCheck();
            // debug();
        }

        document.addEventListener('mousedown', mouseListener);
        document.addEventListener('keydown', keyListener);

    	var scene = new THREE.Scene();
        size_of_scene = 90;
		var camera = new THREE.PerspectiveCamera( size_of_scene, window.innerWidth / window.innerHeight, start_of_scene_z, end_of_scene_z );  // camera perspective
        camera.position.z = 2;

		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight);  //cube lesson size on the screen
		document.body.appendChild( renderer.domElement);

		var geometry = new THREE.BoxGeometry( 1, 1, 1 );
		const loader = new THREE.TextureLoader();
        var front_img = 'images/front.png'
        var back_img = 'images/back.png'
        var left_img = 'images/left.png'
        var right_img = 'images/right.png'
        var up_img = 'images/up.png'
        var down_img = 'images/down.png'
        materials = [
            new THREE.MeshBasicMaterial({map: loader.load(right_img)}), // right
            new THREE.MeshBasicMaterial({map: loader.load(left_img)}),  // left
            new THREE.MeshBasicMaterial({map: loader.load(up_img)}),    // up
            new THREE.MeshBasicMaterial({map: loader.load(down_img)}),  // down
            new THREE.MeshBasicMaterial({map: loader.load(front_img)}), // front
            new THREE.MeshBasicMaterial({map: loader.load(back_img)}),  // back
        ];
        cube = new THREE.Mesh(geometry, materials);
        scene.add( cube );
  		render();
        
    </script>
  </body>
</html>
